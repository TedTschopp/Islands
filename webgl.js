"use strict";

/*
Rendering (WebGL)

This file contains all drawing logic:

- Terrain: Delaunay-ish triangles generated by `create_voronoi_tiling` in `voronoi.js`.
	- Geometry: `triangle_vertices` (Float32Array, 2 floats per vertex)
	- Topology:  `triangle_cells` (Uint32Array, maps each triangle vertex â†’ cell index)
	- Per-vertex data: `data_buffer` (Float32Array, 4 floats per vertex)

- Coastlines: line segments representing where water crosses the lake/sea threshold.
- Rivers: line segments for drainage edges, opacity based on `discharge[...]`.

Key extension points:
- Visual style (colors, banding, water shading): edit the fragment shader `f`.
- What gets drawn each frame: edit `render()` in `index.html`.
- Adding a new overlay: follow the patterns in `draw_rivers`/`draw_coastlines`.

Coordinate conventions:
- `cell_x/cell_y` are in pixel coordinates (canvas space).
- The shaders map pixel coordinates into clip space with a hard-coded 0.8 scale.
*/

let gl;
let canvas = document.getElementById("map_canvas")
canvas.width = pixel_width*0.8;
canvas.height = pixel_height*0.8;
setup_GL();

// ---------------------------------------------------------------------------
// Line shader: used for both coastlines and rivers.
// - Attribute `in_position`: vec2 (pixel coords)
// - Attribute `in_opacity`:  float/byte (0..255)
// ---------------------------------------------------------------------------


let line_vertex = `
	attribute vec2 in_position;
	attribute float in_opacity;
	uniform vec2 canvas_dimensions;
	varying float opacity;
	void main()
	{
		opacity = in_opacity;
		gl_Position = vec4(-1.0+0.8*2.0*in_position.x/canvas_dimensions.x,
									1.0-0.8*2.0*in_position.y/canvas_dimensions.y, 0.0, 1.0);
	}`;
let line_fragment = `
	#ifdef GL_ES
		precision highp float;
	#endif
	varying float opacity;
	void main()
	{
		//gl_FragColor = vec4(88.0, 118.0, 197.0, opacity)/255.0;
		gl_FragColor = vec4(vec3(0.0), opacity)/255.0;
	}`;
let line_shader = setup_shader(line_vertex, line_fragment);
gl.useProgram(line_shader);
line_shader.in_position = gl.getAttribLocation(line_shader, "in_position");
line_shader.in_opacity = gl.getAttribLocation(line_shader, "in_opacity");
line_shader.canvas_dimensions = gl.getUniformLocation(line_shader, "canvas_dimensions");
gl.uniform2fv(line_shader.canvas_dimensions, [canvas.width, canvas.height]);

gl.coastline_vertex_buffer = gl.createBuffer();
let coastline_vertex_buffer = new Float32Array(triangle_count*4);
let coastline_write_position;
gl.bindBuffer(gl.ARRAY_BUFFER, gl.coastline_vertex_buffer);
gl.bufferData(gl.ARRAY_BUFFER, coastline_vertex_buffer, gl.DYNAMIC_DRAW);

gl.coastline_opacity_buffer = gl.createBuffer();
let coastline_opacity_buffer = new Uint8Array(triangle_count*2);
for (let i=0; i<triangle_count*2; i++) { coastline_opacity_buffer[i] = 128; }
gl.bindBuffer(gl.ARRAY_BUFFER, gl.coastline_opacity_buffer);
gl.bufferData(gl.ARRAY_BUFFER, coastline_opacity_buffer, gl.STATIC_DRAW);

gl.river_vertex_buffer = gl.createBuffer();
let river_vertex_buffer = new Float32Array(cell_count*8); //2 segments per cell, 4 floats per segment
let river_write_position;
gl.bindBuffer(gl.ARRAY_BUFFER, gl.river_vertex_buffer);
gl.bufferData(gl.ARRAY_BUFFER, river_vertex_buffer, gl.DYNAMIC_DRAW);

gl.river_opacity_buffer = gl.createBuffer();
let river_opacity_buffer = new Uint8ClampedArray(cell_count*4);
gl.bindBuffer(gl.ARRAY_BUFFER, gl.river_opacity_buffer);
gl.bufferData(gl.ARRAY_BUFFER, river_opacity_buffer, gl.DYNAMIC_DRAW);

// ---------------------------------------------------------------------------
// Hex grid overlay (supports multiple grids)
//
// Draws a regular pointy-top hex grid in pixel coordinates on top of the map.
// The grid is generated in JS and rendered using the same line shader as
// rivers/coastlines.
//
// Multiple grids (e.g. 5-mile and 30-mile) are supported by caching one set of
// buffers per (size, opacity).
// ---------------------------------------------------------------------------

const hex_grid_cache = new Map();

function get_hex_grid_cache_key(hex_flat_to_flat_miles, opacity, width_px, height_px)
{
	// Include map dimensions so grids regenerate correctly if the simulation size changes.
	return `${width_px}x${height_px}|${hex_flat_to_flat_miles}|${opacity}`;
}

function get_or_create_hex_grid(hex_flat_to_flat_miles = 5, opacity = 128)
{
	// Cover the full simulation pixel extent (not the canvas pixel extent).
	const width_px = pixel_width;
	const height_px = pixel_height;

	const key = get_hex_grid_cache_key(hex_flat_to_flat_miles, opacity, width_px, height_px);
	const cached = hex_grid_cache.get(key);
	if (cached) return cached;

	// Size definition:
	// - "flat-to-flat" = distance between two opposite flat sides of the hex.
	// - This also equals the center-to-center spacing when moving across a shared edge.
	// We use a pointy-top layout where horizontal flat-to-flat width is:
	//   W = sqrt(3) * side_length
	const miles_to_meters = 1609.344;
	const width_m = hex_flat_to_flat_miles * miles_to_meters;
	const W = width_m / pixel_length; // pixels
	const side = W / Math.sqrt(3);
	if (!(W > 0) || !(side > 0)) return null;

	// Grid spacing for pointy-top hexes
	const x_step = W;           // sqrt(3) * side
	const y_step = 1.5 * side;  // 3/2 * side

	// Anchor the grid so that (q=0,r=0) is exactly the center of the map.
	// This ensures multiple grid sizes share the same origin and therefore line up.
	const origin_x = width_px * 0.5;
	const origin_y = height_px * 0.5;

	// We generate the grid in axial coordinates (q,r) for pointy-top hexes.
	// Center position formula:
	//   x = origin_x + x_step * (q + r/2)
	//   y = origin_y + y_step * r
	// which matches our line-step geometry and keeps the same orientation across grids.
	const margin = 2 * side;
	const r_min = Math.floor((-origin_y - margin) / y_step);
	const r_max = Math.ceil((height_px - origin_y + margin) / y_step);

	let hex_count = 0;
	const row_ranges = [];
	for (let r = r_min; r <= r_max; r++)
	{
		const q_min = Math.floor((-origin_x - (x_step * 0.5) * r - margin) / x_step);
		const q_max = Math.ceil((width_px - origin_x - (x_step * 0.5) * r + margin) / x_step);
		row_ranges.push([r, q_min, q_max]);
		hex_count += (q_max - q_min + 1);
	}

	// 6 line segments per hex, 4 floats per segment (x1,y1,x2,y2)
	const segment_count = hex_count * 6;
	const vertex_data = new Float32Array(segment_count * 4);
	const opacity_data = new Uint8ClampedArray(segment_count * 2);
	opacity_data.fill(opacity);

	let write = 0;
	for (let i = 0; i < row_ranges.length; i++)
	{
		const [r, q_min, q_max] = row_ranges[i];
		const cy = origin_y + y_step * r;
		for (let q = q_min; q <= q_max; q++)
		{
			const cx = origin_x + x_step * q + (x_step * 0.5) * r;

			// Compute the 6 vertices (pointy-top). Angle starts at -30 degrees.
			let vx = new Array(6);
			let vy = new Array(6);
			for (let k = 0; k < 6; k++)
			{
				const a = (Math.PI / 180) * (60 * k - 30);
				vx[k] = cx + side * Math.cos(a);
				vy[k] = cy + side * Math.sin(a);
			}

			for (let k = 0; k < 6; k++)
			{
				const k2 = (k + 1) % 6;
				vertex_data[write] = vx[k];
				vertex_data[write + 1] = vy[k];
				vertex_data[write + 2] = vx[k2];
				vertex_data[write + 3] = vy[k2];
				write += 4;
			}
		}
	}

	const vertex_buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
	gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);

	const opacity_buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, opacity_buffer);
	gl.bufferData(gl.ARRAY_BUFFER, opacity_data, gl.STATIC_DRAW);

	const grid = {
		segment_count,
		vertex_buffer,
		opacity_buffer,
	};
	hex_grid_cache.set(key, grid);
	return grid;
}

function draw_hex_grid(hex_flat_to_flat_miles = 5, opacity = 32, line_width = 1)
{
	const grid = get_or_create_hex_grid(hex_flat_to_flat_miles, opacity);
	if (!grid || grid.segment_count === 0) return;

	gl.useProgram(line_shader);
	gl.enableVertexAttribArray(line_shader.in_position);
	gl.bindBuffer(gl.ARRAY_BUFFER, grid.vertex_buffer);
	gl.vertexAttribPointer(line_shader.in_position, 2, gl.FLOAT, false, 0, 0);

	gl.enableVertexAttribArray(line_shader.in_opacity);
	gl.bindBuffer(gl.ARRAY_BUFFER, grid.opacity_buffer);
	gl.vertexAttribPointer(line_shader.in_opacity, 1, gl.UNSIGNED_BYTE, false, 0, 0);

	gl.lineWidth(line_width);
	gl.drawArrays(gl.LINES, 0, grid.segment_count * 2);
	gl.disableVertexAttribArray(line_shader.in_position);
}
/************************************************************************
 ************************************************************************/

function draw_rivers(lower_threshold, reference, line_width)
{
	// Rivers are drawn as line segments along cell-to-neighbour edges.
	// `discharge[position]` is computed in `run_drainage(dt)` (see `drainage.js`).
	//
	// Parameters:
	// - `lower_threshold`: skip segments with discharge below this.
	// - `reference`: opacity scaling reference (opacity ~ sqrt(discharge/reference)).
	// - `line_width`: forwarded to `gl.lineWidth`.
	river_write_position = 0;
	for (let cell=0; cell<cell_count; cell++)
	{
		if (lake_thickness[cell] > 50) continue; //unlikely to be a river coming out
		let x = cell_x[cell];
		let y = cell_y[cell];
		for (let j=0; j<cell_neighbour_count[cell]; j++)
		{
			let position = cell*max_neighbours + j;
			let other_cell = cell_neighbours[position];
			if (discharge[position] < lower_threshold) continue;
			//if (discharge[position] >= upper_threshold && upper_threshold != -1) continue;
			if (lake_thickness[cell]>lake_threshold && lake_thickness[other_cell]>lake_threshold) continue;
			let other_x = cell_x[other_cell];
			let other_y = cell_y[other_cell];
			if (lake_thickness[cell]>lake_threshold)
			{
				x = 0.5*(x+other_x);
				y = 0.5*(y+other_y);
			}
			if (lake_thickness[other_cell]>lake_threshold)
			{
				other_x = 0.5*(x+other_x);
				other_y = 0.5*(y+other_y);
			}
			let opacity = 255 * Math.sqrt(discharge[position]/reference);
			river_vertex_buffer[river_write_position*4] = x;
			river_vertex_buffer[river_write_position*4+1] = y;
			river_vertex_buffer[river_write_position*4+2] = other_x;
			river_vertex_buffer[river_write_position*4+3] = other_y;
			river_opacity_buffer[river_write_position*2] = opacity;
			river_opacity_buffer[river_write_position*2+1] = opacity;
			river_write_position += 1;
		}
	}
	gl.useProgram(line_shader);
	gl.enableVertexAttribArray(line_shader.in_position);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.river_vertex_buffer);
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, river_vertex_buffer);
	gl.vertexAttribPointer(line_shader.in_position, 2, gl.FLOAT, false, 0, 0);

	gl.enableVertexAttribArray(line_shader.in_opacity);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.river_opacity_buffer);
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, river_opacity_buffer);
	gl.vertexAttribPointer(line_shader.in_opacity, 1, gl.UNSIGNED_BYTE, false, 0, 0);
	gl.lineWidth(line_width);
	gl.drawArrays(gl.LINES, 0, river_write_position*2);
	gl.disableVertexAttribArray(line_shader.in_position);
}

/******************************************************************************/

function draw_coastlines(line_width = 1)
{
	// Coastlines are computed per triangle by intersecting the water surface
	// with triangle vertices (piecewise-linear isolines).
	coastline_write_position = 0;
	for (let tri=0; tri<triangle_count; tri++)
	{
		add_lake_edges_on_triangle(tri);
	}
	gl.useProgram(line_shader);
	gl.enableVertexAttribArray(line_shader.in_position);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.coastline_vertex_buffer);
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, coastline_vertex_buffer);
	gl.vertexAttribPointer(line_shader.in_position, 2, gl.FLOAT, false, 0, 0);

	gl.enableVertexAttribArray(line_shader.in_opacity);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.coastline_opacity_buffer);
	gl.vertexAttribPointer(line_shader.in_opacity, 1, gl.UNSIGNED_BYTE, false, 0, 0);
	gl.lineWidth(line_width);
	gl.drawArrays(gl.LINES, 0, coastline_write_position/2);
	gl.disableVertexAttribArray(line_shader.in_position);
}

function add_lake_edges_on_triangle(tri)
{
	let a = triangle_cells[tri*3];
	let b = triangle_cells[tri*3+1];
	let c = triangle_cells[tri*3+2];
	if (lake_thickness[a]<lake_threshold) // a is dry
	{
		let temp = a; a = c; c = temp; // now c is dry
		if (lake_thickness[b]>lake_thickness[a])
		{
			let temp = a; a = b; b = temp;
		}
	}
	else // a is wet
	{
		if (lake_thickness[c]>lake_thickness[b])
		{
			let temp = b; b = c; c = temp;
		}
	}
	if (lake_thickness[a] < lake_threshold) return; //all dry
	if (lake_thickness[c] > lake_threshold) return; //all wet
	if (lake_thickness[b] < lake_threshold) // a wet; b, c dry
	{
		let start_fraction = (lake_thickness[a]-lake_threshold) /(cell_elevation[b]-cell_elevation[a]);
		let end_fraction = (lake_thickness[a]-lake_threshold) /(cell_elevation[c]-cell_elevation[a]);
		add_lake_edge(a, b, c, start_fraction, end_fraction);
	}
	else // a, b wet;  c dry
	{
		let start_fraction = 1 - (lake_thickness[a]-lake_threshold) /(cell_elevation[c]-cell_elevation[a]);
		let end_fraction = 1 - (lake_thickness[b]-lake_threshold) /(cell_elevation[c]-cell_elevation[b]);
		add_lake_edge(c, a, b, start_fraction, end_fraction);
	}
}

function add_lake_edge(a,b,c, start_fraction, end_fraction)
{
	if (start_fraction<0.0 || start_fraction>1.0) return;
	if (end_fraction<0.0 || end_fraction>1.0) return;
	//start_fraction = 0.5;
	//end_fraction = 0.5;
	let start_x = cell_x[a] * (1-start_fraction) + cell_x[b] * start_fraction;
	let start_y = cell_y[a] * (1-start_fraction) + cell_y[b] * start_fraction;
	let end_x = cell_x[a] * (1-end_fraction) + cell_x[c] * end_fraction;
	let end_y = cell_y[a] * (1-end_fraction) + cell_y[c] * end_fraction;
	coastline_vertex_buffer[coastline_write_position] = start_x;
	coastline_vertex_buffer[coastline_write_position+1] = start_y;
	coastline_vertex_buffer[coastline_write_position+2] = end_x;
	coastline_vertex_buffer[coastline_write_position+3] = end_y;
	coastline_write_position += 4;
}

/****************************************************************************/

let v = `
	attribute vec2 aVertexPosition;
   attribute vec4 in_data;
	attribute vec3 in_normal;
   uniform vec2 canvas_dimensions;
   varying float elevation;
	varying float lake_thickness;
	varying float wet;
	varying float water_level;
	varying vec3 normal;
	varying float triangle_shade;
	void main()
	{
		// Per-vertex data packing (see draw_mesh() in webgl.js):
		// - in_data.x: elevation above mean sea level (meters)
		// - in_data.y: triangle water level (meters, relative to mean sea level)
		// - in_data.w: precomputed triangle shade (dimensionless)
		/* // DECODE TERRAIN DATA PACKED AS 4xUINT8
		elevation = 255.0*in_data.x + in_data.y - 1000.0;
		wet = in_data.z;
		lake_thickness = 1.0;
		if (wet > 1.0)
		{
			lake_thickness = (wet-1.0)*20.0;
			wet = 1.0;
		}
		triangle_shade = (in_data.w - 128.0)/100.0;*/

      elevation = in_data.x;
		water_level = in_data.y;
		//lake_thickness = in_data.y;
		//wet = in_data.z;
		triangle_shade = in_data.w;

		normal = normalize(in_normal);
		gl_Position = vec4(-1.0+0.8*2.0*aVertexPosition.x/canvas_dimensions.x,
                           1.0-0.8*2.0*aVertexPosition.y/canvas_dimensions.y, 0.0, 1.0);
	}`;

let f = `
	#ifdef GL_ES
	precision highp float; //Don't know why this stuff is here
	#endif
   varying float elevation;
	varying float lake_thickness;
	varying float wet;
	varying vec3 normal;
	varying float triangle_shade;
	varying float water_level;
	void main()
   {
		// Visual style lives here.
		// - Adjust terrain banding/ramps by editing the colour_* values.
		// - Adjust water appearance by editing the elevation<water_level branch.
		vec3 sea_colour = vec3(120.0, 165.0, 255.0)/255.0;
		vec3 deep_sea_colour = vec3(94.0, 130.0, 226.0)/255.0;

		/*vec3 colour_low = vec3(120.0, 165.0, 116.0)/255.0;
		vec3 colour_500m = vec3(170.0, 220.0, 150.0)/255.0;
		vec3 colour_1000m = vec3(238.0, 235.0, 194.0)/255.0;
		vec3 colour_2000m = vec3(172.0, 155.0, 127.0)/255.0;
		vec3 colour_5000m = vec3(244.0, 245.0, 240.0)/255.0;*/

      vec3 colour_0m = vec3(0.0, 97.0, 71.0)/255.0;
      vec3 colour_50m = vec3(16.0, 122.0, 47.0)/255.0;
      vec3 colour_500m = vec3(232.0, 215.0, 125.0)/255.0;
      vec3 colour_1200m = vec3(161.0, 67.0, 0.0)/255.0;
      vec3 colour_1700m = vec3(158.0, 0.0, 0.0)/255.0;
      vec3 colour_2800m = vec3(160.0, 160.0, 160.0)/255.0;
      vec3 colour_4000m = vec3(240.0, 240.0, 240.0)/255.0;

		float shade = 1.0 + 1.0*triangle_shade;
      shade = clamp(shade, 0.5, 1.5);
		vec3 tint;

		//float elevation_step = 200.0*floor(elevation/200.0-0.5)+50.0;
		/*if (wet > 0.5)
		{
         float step = floor(lake_thickness/600.0+0.05);
			tint = mix(sea_colour, deep_sea_colour, step/1.5);
			shade = 1.0; //  + normal.x * -1.0 + normal.y*-1.0;
		}*/

		if (elevation<water_level)
		{
			float step = floor((water_level-elevation)/600.0+0.05);
			tint = mix(sea_colour, deep_sea_colour, step/1.5);
			shade = 1.0;
		}
		else if (elevation<0.0) tint = colour_0m;
		else if (elevation<50.0) tint = mix(colour_0m, colour_50m, elevation/50.0);
		else if (elevation<500.0) tint = mix(colour_50m, colour_500m, (elevation-50.0)/450.0);
		else if (elevation<1200.0) tint = mix(colour_500m, colour_1200m,  (elevation-500.0)/700.0);
		else if (elevation<1700.0) tint = mix(colour_1200m, colour_1700m,  (elevation-1200.0)/500.0);
		else if (elevation<2800.0)  tint = mix(colour_1700m, colour_2800m, (elevation-1700.0)/900.0);
      else if (elevation<4000.0)  tint = mix(colour_2800m, colour_4000m, (elevation-2800.0)/1200.0);
		else tint = colour_4000m;
		/*else if (elevation_step<500.0) tint = mix(colour_low, colour_500m, elevation_step/500.0);
		else if (elevation_step<1000.0) tint = mix(colour_500m, colour_1000m, (elevation_step-500.0)/500.0);
		else if (elevation_step<2000.0) tint = mix(colour_1000m, colour_2000m,  (elevation_step-1000.0)/1000.0);
		else if (elevation_step<5000.0)  tint = mix(colour_2000m, colour_5000m, (elevation_step-2000.0)/3000.0);
		else tint = colour_5000m;*/
        tint = mix(tint, vec3(dot(vec3(0.3, 0.55, 0.15), tint)), 0.2);
        tint = mix(tint, vec3(0.9), 0.2);
		gl_FragColor = vec4(shade*tint, 1.0);
   }`;

let terrain_shader = setup_shader(v, f);
gl.useProgram(terrain_shader);
terrain_shader.in_normal = gl.getAttribLocation(terrain_shader, "in_normal");
terrain_shader.in_data = gl.getAttribLocation(terrain_shader, "in_data");
terrain_shader.aVertexPosition = gl.getAttribLocation(terrain_shader, "aVertexPosition");
terrain_shader.canvas_dimensions = gl.getUniformLocation(terrain_shader, "canvas_dimensions");
gl.uniform2fv(terrain_shader.canvas_dimensions, [canvas.width, canvas.height]);

gl.terrain_vertex_buffer = gl.createBuffer();
gl.terrain_data_buffer = gl.createBuffer();

//let data_buffer = new Uint8ClampedArray(triangle_count*3*4);
let data_buffer = new Float32Array(triangle_count*3*4);
let triangle_shade = new Float32Array(triangle_count);
let cell_shade = new Float32Array(cell_count);

gl.bindBuffer(gl.ARRAY_BUFFER, gl.terrain_vertex_buffer);
gl.bufferData(gl.ARRAY_BUFFER, triangle_vertices, gl.STATIC_DRAW);

gl.bindBuffer(gl.ARRAY_BUFFER, gl.terrain_data_buffer);
gl.bufferData(gl.ARRAY_BUFFER, data_buffer, gl.DYNAMIC_DRAW);

function draw_mesh(elevation_array)
{
	// Update per-vertex data buffer and draw the full triangle mesh.
	//
	// `elevation_array` is typically `cell_elevation` (bedrock + sediment),
	// but you can pass any per-cell scalar field to visualize it.
	calculate_shades(elevation_array);
   for (let tri=0; tri<triangle_count; tri++)
   {
      let shade = triangle_shade[tri];
		let a = triangle_cells[tri*3];
		let b = triangle_cells[tri*3+1];
		let c = triangle_cells[tri*3+2];
		let water_level = Math.min(elevation_array[a]+lake_thickness[a],
            elevation_array[b] + lake_thickness[b],
            elevation_array[c] + lake_thickness[c]) - mean_sea_level - lake_threshold;

		// `water_level` is a triangle-constant surface height (relative to mean sea
		// level) used by the shader to decide if each fragment is underwater.

      for (let j=0; j<3; j++)
      {
         let i = tri*3+j;
         let cell = triangle_cells[i];
			/*let elevation = (1000 + elevation_array[cell] - mean_sea_level) | 0;
			data_buffer[4*i] = elevation >> 8;
			data_buffer[4*i+1] = elevation & 255;
			let lt = lake_thickness[cell];
			if (lt < 200) lt = (lt>lake_threshold) ? 1 : 0;
			else lt = (((lt/20)|0)+1) & 255;
			data_buffer[4*i+2] = lt;
			//let mixed_shade = 0.3*cell_shade[cell] + 0.7*shade;
			data_buffer[4*i+3] = (128+shade * 100) | 0;*/

         data_buffer[4*i] = elevation_array[cell]-mean_sea_level;
			data_buffer[4*i+1] = water_level;
         //data_buffer[4*i+1] = lake_thickness[cell]; //TODO - assign same water level to all points on the triangle
         //data_buffer[4*i+2] = (lake_thickness[cell]>lake_threshold) ? 1 : 0;
         data_buffer[4*i+3] = shade;
      }
	}
	gl.useProgram(terrain_shader);
	do_buffers();
	do_draw();
}

function do_buffers()
{
	gl.enableVertexAttribArray(terrain_shader.in_data);
	gl.enableVertexAttribArray(terrain_shader.aVertexPosition);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.terrain_vertex_buffer);
	gl.vertexAttribPointer(terrain_shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.terrain_data_buffer);
   gl.bufferSubData(gl.ARRAY_BUFFER, 0, data_buffer);
	gl.vertexAttribPointer(terrain_shader.in_data, 4, gl.FLOAT, false, 0, 0);
}

function do_draw()
{
	gl.drawArrays(gl.TRIANGLES, 0, triangle_count * 3);
}

function calculate_shades(elevation_array)
{
	// Approximate a triangle normal via cross product in (x,y,z) space, then
	// project it into a simple shading scalar. This is intentionally cheap.
	//for (let cell=0; cell<cell_count; cell++) { cell_shade[cell] = 0; }
	for (let tri=0; tri<triangle_count; tri++)
	{
		let i = triangle_cells[tri*3];
		let j = triangle_cells[tri*3+1];
		let k = triangle_cells[tri*3+2];

      // u goes i->j; v goes i->k
      let ux = (cell_x[j] - cell_x[i]) * pixel_length;
      let uy = (cell_y[j] - cell_y[i]) * pixel_length;
      let uz = elevation_array[j] - elevation_array[i];
      let vx = (cell_x[k] - cell_x[i]) * pixel_length;
      let vy = (cell_y[k] - cell_y[i]) * pixel_length;
      let vz = elevation_array[k] - elevation_array[i];
      // c is cross product
      let cx = uy*vz - uz*vy;
      let cy = uz*vx - ux*vz;
      let cz = ux*vy - uy*vx;

		let shade = - (cx + cy)/cz; //flat_normal_length[tri];
		triangle_shade[tri] = shade;
		//cell_shade[i] += shade;
		//cell_shade[j] += shade;
		//cell_shade[k] += shade;
	}
	//for (let cell=0; cell<cell_count; cell++) { cell_shade[cell] /= cell_neighbour_count[cell]; }
}

function setup_GL()
{
	gl = canvas.getContext("webgl",{alpha: false});
	//, {preserveDrawingBuffer: true});
	gl.viewport(0, 0, canvas.width, canvas.height);
	//gl.clearColor(0.0, 0.0, 0.0, 1.0);
	//gl.clear(gl.COLOR_BUFFER_BIT);
	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	//gl.enable(gl.LINE_SMOOTH);
}

function setup_shader(v, f)
{
	let vs = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vs, v);
	gl.compileShader(vs);

	let fs = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fs, f);
	gl.compileShader(fs);

	let program = gl.createProgram();
	gl.attachShader(program, vs);
	gl.attachShader(program, fs);
	gl.linkProgram(program);

	if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
				console.log(gl.getShaderInfoLog(vs));
	if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
				console.log(gl.getShaderInfoLog(fs));
	if (!gl.getProgramParameter(program, gl.LINK_STATUS))
				console.log(gl.getProgramInfoLog(program));

	return program;
}
